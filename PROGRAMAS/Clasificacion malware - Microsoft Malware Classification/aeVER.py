"""
Nombre del codigo: Visualizar original, comprimida y reconstruida del autoencoder convolucional
Base de datos: Microsoft Malware Dataset
Alumno: Jiménez Poyatos, Pablo
"""

import pickle
import numpy as np
import matplotlib.pyplot as plt

from tensorflow.keras.models import load_model, Model
from sklearn.model_selection import train_test_split


def load_and_prepare_data(file_path: str, test_size: float = 0.001, random_state: int = 90) -> tuple:
    """
    Carga y prepara los datos del archivo pickle especificado.

    Args:
        file_path (str): La ruta del archivo pickle que contiene los datos.
        test_size (float): La fracción de datos a utilizar como conjunto de prueba.
        random_state (int): La semilla para la división aleatoria de los datos.

    Returns:
        tuple: Una tupla que contiene los conjuntos de datos de entrenamiento y prueba, y sus etiquetas correspondientes.
    """
    with open(file_path, 'rb') as f:
        data, labels = pickle.load(f)
    labels = labels.astype(np.int64)
    X_train, X_test, y_train, y_test = train_test_split(data, labels, test_size=test_size, random_state=random_state)
    return X_train, X_test, y_train, y_test

def normalize_images(images: np.ndarray) -> np.ndarray:
    """
    Normaliza las imágenes dividiéndolas por 255.

    Args:
        images (np.ndarray): Un array numpy que contiene las imágenes a normalizar.

    Returns:
        np.ndarray: Un array numpy con las imágenes normalizadas.
    """
    return images / 255.0

def plot_images(X_test: np.ndarray, encoded_imgs: np.ndarray, decoded_imgs: np.ndarray, n: int = 4) -> None:
    """
    Muestra las imágenes originales, codificadas y reconstruidas.

    Args:
        X_test (np.ndarray): Conjunto de imágenes originales.
        encoded_imgs (np.ndarray): Conjunto de imágenes codificadas.
        decoded_imgs (np.ndarray): Conjunto de imágenes reconstruidas.
        n (int): Número de imágenes a mostrar.
    """
    plt.figure(figsize=(18, 8))
    average_encoded_imgs = np.mean(encoded_imgs, axis=-1)

    for i in range(n):
        # original
        plt.subplot(n, 3, 3*i + 1)
        plt.imshow(X_test[i])
        plt.title("Original")
        plt.axis('off')

        # comprimida
        plt.subplot(n, 3, 3*i + 2)
        plt.imshow(average_encoded_imgs[i], cmap='gray')
        plt.title("Encoded")
        plt.axis('off')

        # Reconstruccion
        plt.subplot(n, 3, 3*i + 3)
        plt.imshow(decoded_imgs[i])
        plt.title("Reconstructed")
        plt.axis('off')
        plt.savefig(f"{i}.png")

    plt.show()

if __name__ == "__main__":
    autoencoder = load_model('MMC_autoencoder_ae.keras')

    # Suponiendo que la capa comprimida es la última capa de MaxPooling2D antes de la primera UpSampling2D
    encoder = Model(inputs=autoencoder.input, outputs=autoencoder.get_layer(index=10).output)

    # Cargar y preparar los datos
    X_train, X_test, y_train, y_test = load_and_prepare_data('eliminarL.pkl')

    # Normalizar las imágenes de prueba
    X_test = normalize_images(X_test)

    # Obtener las imágenes codificadas y reconstruidas
    encoded_imgs = encoder.predict(X_test)
    decoded_imgs = autoencoder.predict(X_test)

    # Mostrar las imágenes
    plot_images(X_test, encoded_imgs, decoded_imgs, n=4)

