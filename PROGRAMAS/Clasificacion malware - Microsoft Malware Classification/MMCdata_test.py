"""
Nombre del codigo: Procesamiento de los datos de prueba de la base de datos Microsoft Malware Clasificacion

Alumno: Jimenez Poyatos, Pablo
Trabajo: Algoritmos de aprendizaje automático aplicados a problemas en ciberseguridad.

"""

from math import floor, sqrt
from PIL import Image

import numpy as np
import matplotlib.pyplot as plt
import csv
import os
import multiprocessing as mp
import pickle
import cv2



def reparte(numero: int, nr_partes: int) -> list[int]:
    """Divide `numero` en `nr_partes` partes enteras más o menos iguales.
    Por ejemplo, reparte(10, 3) devuelve la lista [4, 3, 3]."""
    cociente, resto = divmod(numero, nr_partes)
    return [cociente + 1] * resto + [cociente] * (nr_partes - resto)

def generar_listas(lista: list[int], totales: list[int]) -> list[list[int]]:
    """Genera listas de valores divididos en partes especificadas por `lista`.

    Args:
        lista (list[int]): Lista de longitudes para las nuevas listas.
        totales (list[int]): Lista total de valores.

    Returns:
        list[list[int]]: Lista de listas con valores divididos.
    """
    resultado = []
    inicio = 0

    for longitud in lista:
        nueva_lista = totales[inicio:longitud + 1]
        resultado.append(nueva_lista)
        totales = totales[longitud + 1:]

    return resultado

def concat(xss: list[list[int]]) -> list[int]:
    """Concatena una lista de listas en una sola lista.

    Args:
        xss (list[list[int]]): Lista de listas a concatenar.

    Returns:
        list[int]: Lista concatenada.
    """
    xs = []
    for i in xss:
        xs += i
    return xs

def eliminar(lista: list[str], caracter: str, _) -> list[str]:
    """Elimina elementos de una lista que contienen un caracter específico.

    Args:
        lista (list[str]): Lista de strings.
        caracter (str): Caracter a eliminar de la lista.

    Returns:
        list[str]: Lista sin los elementos que contienen el caracter.
    """
    return list(filter(lambda byte: caracter not in byte, lista))

def sustituir(lista: list[str], caracter: str, valor: str) -> list[str]:
    """Sustituye elementos de una lista que contienen un caracter específico con un valor dado.

    Args:
        lista (list[str]): Lista de strings.
        caracter (str): Caracter a buscar en la lista.
        valor (str): Valor para sustituir los elementos que contienen el caracter.

    Returns:
        list[str]: Lista con los elementos sustituidos.
    """
    modif = []
    for i in range(len(lista)):
        if caracter in lista[i]:
            modif.append(valor)
        else:
            modif.append(lista[i])
    return modif

def encontrar_mayor_cuadrado(image_array: np.ndarray) -> np.ndarray:
    """Encuentra el mayor cuadrado posible dentro de un array y lo convierte en una matriz.

    Args:
        image_array (np.ndarray): Array de la imagen.

    Returns:
        np.ndarray: Matriz cuadrada de la imagen.
    """
    lon = len(image_array)
    lado = floor(sqrt(lon))
    if lado == 0:
        return np.empty((0, 0))

    lado2 = lon // lado
    image_array = image_array[:lado * lado2]
    image_matrix = image_array.reshape((lado, lado2)).astype(np.uint8)
    return image_matrix

def random_crop(image_array: np.ndarray, crop_size: tuple[int, int] = (224, 224)) -> np.ndarray:
    """Recorta aleatoriamente una imagen a un tamaño dado.

    Args:
        image_array (np.ndarray): Array de la imagen.
        crop_size (tuple[int, int]): Tamaño del recorte.

    Returns:
        np.ndarray: Imagen recortada.
    """
    image = Image.fromarray(image_array.astype(np.uint8))
    original_width, original_height = image.size
    left = np.random.randint(0, original_width - crop_size[0] + 1)
    top = np.random.randint(0, original_height - crop_size[1] + 1)
    right = left + crop_size[0]
    bottom = top + crop_size[1]
    cropped_image = image.crop((left, top, right, bottom))
    cropped_matrix = np.array(cropped_image)
    return cropped_matrix

def ajustar_tamano(image_array: np.ndarray, width: int, height: int, metodo: int) -> np.ndarray:
    """Ajusta el tamaño de una imagen utilizando un método de interpolación.

    Args:
        image_array (np.ndarray): Array de la imagen.
        width (int): Ancho deseado.
        height (int): Alto deseado.
        metodo (int): Método de interpolación.

    Returns:
        np.ndarray: Imagen ajustada.
    """
    image_matrix = encontrar_mayor_cuadrado(image_array)
    if image_matrix.size == 0:
        return image_matrix
    else:
        interpolation_methods = [cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_NEAREST]
        if metodo in interpolation_methods:
            new_shape = (width, height)
            image = cv2.resize(image_matrix, new_shape, interpolation=metodo)
        else:
            image = random_crop(image_array, (width, height))
    return image

def bytes_to_image(byte_str: list[str], width: int, height: int, metodo: int) -> np.ndarray:
    """Convierte una cadena de bytes en una imagen.

    Args:
        byte_str (list[str]): Cadena de bytes.
        width (int): Ancho deseado.
        height (int): Alto deseado.
        metodo (int): Método de interpolación.

    Returns:
        np.ndarray: Imagen resultante.
    """
    byte_list = [int(byte, 16) for byte in byte_str]
    image_array = np.array(byte_list)
    grayscale_image = ajustar_tamano(image_array, width, height, metodo)
    result_image = np.stack([grayscale_image] * 3, axis=-1)
    return result_image

def file_to_image(name: str, funcion, caracter: str, valor: str, metodo: int) -> np.ndarray:
    """Convierte un archivo en una imagen.

    Args:
        name (str): Nombre del archivo.
        funcion (function): Función a aplicar a los bytes del archivo.
        caracter (str): Caracter a eliminar o sustituir en los bytes.
        valor (str): Valor para sustituir los bytes que contienen el caracter.
        metodo (int): Método de interpolación.

    Returns:
        np.ndarray: Imagen resultante.
    """
    ruta = os.path.join('test')
    ruta_archiv = os.path.join(ruta, name)
    lines = open(ruta_archiv, "r").readlines()
    malware_list = list(map(lambda x: x[:-1].split(" ")[1:], lines))
    malware_bytes_list = concat(malware_list)
    malware_bytes = funcion(malware_bytes_list, caracter, valor)
    malware_image = bytes_to_image(malware_bytes, 224, 224, metodo)
    return malware_image

def visualize_image(image_matrix: np.ndarray, nombre: str) -> None:
    """Visualiza una imagen.

    Args:
        image_matrix (np.ndarray): Matriz de la imagen.
        nombre (str): Nombre de la imagen.
    """
    plt.imshow(image_matrix, cmap='gray')
    plt.axis('off')
    plt.title(nombre)
    plt.show()

def leer_csv_ruta(path: str, file: str) -> tuple[str, dict, list[str]]:
    """Lee un archivo CSV y obtiene la ruta, etiquetas de entrenamiento e imágenes.

    Args:
        path (str): Ruta del directorio.
        file (str): Nombre del archivo CSV.

    Returns:
        tuple: Ruta, etiquetas de entrenamiento e imágenes.
    """
    ruta = os.path.join(path)
    images_tot = os.listdir(ruta)
    images = list(filter(verificar_extension, images_tot))
    trainLabel = leer_csv(file)
    return ruta, trainLabel, images

def leer_csv(name: str) -> dict[str, str]:
    """Lee un archivo CSV y lo convierte en un diccionario.

    Args:
        name (str): Nombre del archivo CSV.

    Returns:
        dict: Diccionario con los datos del CSV.
    """
    diccionario_id_label = {}
    with open(name, newline='') as csvfile:
        lector = csv.DictReader(csvfile)
        for fila in lector:
            id_valor = fila['Id']
            label_valor = fila['Class']
            diccionario_id_label[id_valor] = label_valor
    return diccionario_id_label

def verificar_extension(archivo: str) -> bool:
    """Verifica si la extensión de un archivo es '.bytes'.

    Args:
        archivo (str): Nombre del archivo.

    Returns:
        bool: True si la extensión es '.bytes', False en caso contrario.
    """
    _, extension = os.path.splitext(archivo)
    return extension.lower() == '.bytes'

def load_and_preprocess_data(funcion, images: list[str], caracter: str, valor: str, metodo: int) -> list[np.ndarray]:
    """Carga y procesa datos de imágenes.

    Args:
        funcion (function): Función a aplicar a los bytes de los archivos.
        images (list[str]): Lista de nombres de archivos de imágenes.
        caracter (str): Caracter a eliminar o sustituir en los bytes.
        valor (str): Valor para sustituir los bytes que contienen el caracter.
        metodo (int): Método de interpolación.

    Returns:
        list[np.ndarray]: Lista de imágenes procesadas.
    """
    data = []
    for i in images:
        imagen = file_to_image(i, funcion, caracter, valor, metodo)
        if imagen.size != 0:
            data.append(imagen)
            visualize_image(imagen, 0)
    return data

def load_and_preprocess_data_paralelo(nr_procesos: int, funcion, caracter: str, valor: str, metodo: int) -> np.ndarray:
    """Carga y procesa datos de imágenes en paralelo.

    Args:
        nr_procesos (int): Número de procesos paralelos.
        funcion (function): Función a aplicar a los bytes de los archivos.
        caracter (str): Caracter a eliminar o sustituir en los bytes.
        valor (str): Valor para sustituir los bytes que contienen el caracter.
        metodo (int): Método de interpolación.

    Returns:
        np.ndarray: Array de imágenes procesadas.
    """
    p = mp.Pool(nr_procesos)
    _, _, images = leer_csv_ruta("test", "trainLabels.csv")
    reparto_doc = reparte(len(images), nr_procesos)
    archivos = generar_listas(reparto_doc, images)
    args_list = [(funcion, archivo, caracter, valor, metodo) for archivo in archivos]
    resultados = p.starmap(load_and_preprocess_data, args_list)
    data = np.array(concat(resultados))
    return data


if __name__ == "__main__":
    interpolation_methods = ["random", cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_NEAREST]
    funcion = eliminar
    caracter = "?"
    valor = "-1"
    metodo = cv2.INTER_LINEAR
    _, trainLabel, images = leer_csv_ruta("test", "trainLabels.csv")

    eliminarL_test = load_and_preprocess_data_paralelo(6, funcion, caracter, valor, metodo)
    with open('eliminarL_test.pkl', 'wb') as f:
        pickle.dump(eliminarL_test, f)






