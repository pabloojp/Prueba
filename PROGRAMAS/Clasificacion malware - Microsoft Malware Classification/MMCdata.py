"""
Nombre del codigo: Procesamiento de los datos de la base de datos Microsoft Malware Clasificacion

Alumno: Jimenez Poyatos, Pablo
Trabajo: Algoritmos de aprendizaje automático aplicados a problemas en ciberseguridad.

"""
from math import floor, sqrt
from PIL import Image

import numpy as np
import matplotlib.pyplot as plt
import csv
import os
import multiprocessing as mp
import pickle
import cv2


def reparte(numero: int, nr_partes: int) -> list[int]:
    """
    Divide `numero` en `nr_partes` partes enteras más o menos iguales.

    Args:
        numero (int): El número a dividir.
        nr_partes (int): El número de partes en las que dividir.

    Returns:
        list[int]: Una lista de enteros que representa las partes divididas.
    """
    cociente, resto = divmod(numero, nr_partes)
    return [cociente + 1] * resto + [cociente] * (nr_partes - resto)

def generar_listas(lista: list[int], totales: list) -> list[list]:
    """
    Genera sublistas de `totales` basadas en las longitudes especificadas en `lista`.

    Args:
        lista (list[int]): Una lista de longitudes.
        totales (list): La lista original de la que se generarán las sublistas.

    Returns:
        list[list]: Una lista de sublistas generadas.
    """
    resultado = []
    inicio = 0

    for longitud in lista:
        nueva_lista = totales[inicio:longitud + 1]
        resultado.append(nueva_lista)
        totales = totales[longitud + 1:]

    return resultado

def concat(xss: list[list]) -> list:
    """
    Concatena una lista de listas en una sola lista.

    Args:
        xss (list[list]): La lista de listas a concatenar.

    Returns:
        list: La lista concatenada.
    """
    xs = []
    for i in xss:
        xs += i
    return xs

def eliminar(lista: list, caracter: str, _) -> list:
    """
    Elimina elementos de `lista` que contienen el `caracter` especificado.

    Args:
        lista (list): La lista original.
        caracter (str): El caracter a eliminar.
        _ (any): Un argumento no utilizado.

    Returns:
        list: La lista modificada sin los elementos que contienen el caracter.
    """
    return list(filter(lambda byte: caracter not in byte, lista))

def sustituir(lista: list, caracter: str, valor: any) -> list:
    """
    Sustituye los elementos que contienen `caracter` en `lista` con `valor`.

    Args:
        lista (list): La lista original.
        caracter (str): El caracter a buscar.
        valor (any): El valor con el que reemplazar.

    Returns:
        list: La lista modificada con los valores sustituidos.
    """
    modif = []
    for i in range(len(lista)):
        if caracter in lista[i]:
            modif.append(valor)
        else:
            modif.append(lista[i])
    return modif

def encontrar_mayor_cuadrado(image_array: np.ndarray) -> np.ndarray:
    """
    Encuentra el mayor cuadrado posible dentro de `image_array`.

    Args:
        image_array (np.ndarray): Un arreglo de la imagen.

    Returns:
        np.ndarray: Un arreglo 2D representando el mayor cuadrado.
    """
    lon = len(image_array)
    lado = floor(sqrt(lon))
    if lado == 0:
        return np.empty((0, 0))

    lado2 = lon // lado
    image_array = image_array[:lado * lado2]
    image_matrix = image_array.reshape((lado, lado2)).astype(np.uint8)
    return image_matrix

def random_crop(image_array: np.ndarray, crop_size: tuple[int, int]=(224, 224)) -> np.ndarray:
    """
    Realiza un recorte aleatorio de tamaño `crop_size` en `image_array`.

    Args:
        image_array (np.ndarray): Un arreglo de la imagen.
        crop_size (tuple[int, int]): El tamaño del recorte (ancho, alto).

    Returns:
        np.ndarray: El arreglo de la imagen recortada.
    """
    image = Image.fromarray(image_array.astype(np.uint8))

    original_width, original_height = image.size
    if original_width < 224 or original_height < 224:
        image_matrix = encontrar_mayor_cuadrado(image_array)
        return cv2.resize(image_matrix, crop_size, cv2.INTER_LINEAR)
    left = np.random.randint(0, original_width - crop_size[0] + 1)
    top = np.random.randint(0, original_height - crop_size[1] + 1)
    right = left + crop_size[0]
    bottom = top + crop_size[1]

    cropped_image = image.crop((left, top, right, bottom))
    cropped_matrix = np.array(cropped_image)

    return cropped_matrix

def ajustar_tamano(image_array: np.ndarray, width: int, height: int, metodo: int) -> np.ndarray:
    """
    Ajusta el tamaño de `image_array` a las dimensiones especificadas por `width` y `height`.

    Args:
        image_array (np.ndarray): Un arreglo de la imagen.
        width (int): El ancho deseado.
        height (int): La altura deseada.
        metodo (int): El método de interpolación de OpenCV.

    Returns:
        np.ndarray: El arreglo de la imagen redimensionada.
    """
    image_matrix = encontrar_mayor_cuadrado(image_array)
    if image_matrix.size == 0:
        return image_matrix
    else:
        interpolation_methods = [cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_NEAREST]
        if metodo in interpolation_methods:
            new_shape = (width, height)
            image = cv2.resize(image_matrix, new_shape, interpolation=metodo)
        else:
            image = random_crop(image_array, (width, height))
    return image

def bytes_to_image(byte_str: str, width: int, height: int, metodo: int) -> np.ndarray:
    """
    Convierte una cadena de bytes en una imagen con las dimensiones especificadas.

    Args:
        byte_str (str): La cadena de bytes en formato hexadecimal.
        width (int): El ancho deseado.
        height (int): La altura deseada.
        metodo (int): El método de interpolación de OpenCV.

    Returns:
        np.ndarray: El arreglo de la imagen en escala de grises.
    """
    byte_list = [int(byte, 16) for byte in byte_str]
    image_array = np.array(byte_list)

    grayscale_image = ajustar_tamano(image_array, width, height, metodo)
    result_image = np.stack([grayscale_image] * 3, axis=-1)
    return result_image

def file_to_image(name: str, funcion, caracter: str, valor: any, metodo: int) -> np.ndarray:
    """
    Convierte el contenido de un archivo en una imagen utilizando una función de procesamiento.

    Args:
        name (str): El nombre del archivo.
        funcion (callable): La función de procesamiento a aplicar.
        caracter (str): El caracter a buscar en la función de procesamiento.
        valor (any): El valor de reemplazo para la función de procesamiento.
        metodo (int): El método de interpolación de OpenCV.

    Returns:
        np.ndarray: El arreglo de la imagen procesada.
    """
    ruta = os.path.join('train')
    ruta_archiv = os.path.join(ruta, name)
    lines = open(ruta_archiv, "r").readlines()

    malware_list = list(map(lambda x: x[:-1].split(" ")[1:], lines))
    malware_bytes_list = concat(malware_list)
    malware_bytes = funcion(malware_bytes_list, caracter, valor)
    malware_image = bytes_to_image(malware_bytes, 224, 224, metodo)
    return malware_image

def visualize_image(image_matrix: np.ndarray, nombre: str) -> None:
    """
    Visualiza una imagen con un título especificado.

    Args:
        image_matrix (np.ndarray): El arreglo de la imagen.
        nombre (str): El título de la imagen.

    Returns:
        None
    """
    plt.imshow(image_matrix, cmap='gray')
    plt.axis('off')
    plt.title(nombre)
    plt.show()

def leer_csv_ruta(path: str, file: str) -> tuple[str, dict, list[str]]:
    """
    Lee los datos de un archivo CSV y una ruta de directorio.

    Args:
        path (str): La ruta del directorio.
        file (str): El archivo CSV a leer.

    Returns:
        tuple[str, dict, list[str]]: Una tupla que contiene la ruta, un diccionario de etiquetas y una lista de archivos.
    """
    ruta = os.path.join(path)
    images_tot = os.listdir(ruta)
    images = list(filter(verificar_extension, images_tot))
    trainLabel = leer_csv(file)

    return ruta, trainLabel, images

def leer_csv(name: str) -> dict[str, str]:
    """
    Lee un archivo CSV y devuelve un diccionario de etiquetas.

    Args:
        name (str): El nombre del archivo CSV.

    Returns:
        dict[str, str]: Un diccionario con IDs y sus respectivas etiquetas.
    """
    diccionario_id_label = {}
    with open(name, newline='') as csvfile:
        lector = csv.DictReader(csvfile)
        for fila in lector:
            id_valor = fila['Id']
            label_valor = fila['Class']
            diccionario_id_label[id_valor] = label_valor
    return diccionario_id_label

def verificar_extension(archivo: str) -> bool:
    """
    Verifica si la extensión de un archivo es `.bytes`.

    Args:
        archivo (str): El nombre del archivo.

    Returns:
        bool: True si la extensión es `.bytes`, de lo contrario False.
    """
    _, extension = os.path.splitext(archivo)
    return extension.lower() == '.bytes'

def load_and_preprocess_data(trainLabel: dict[str, str], funcion, images: list[str], caracter: str, valor: any, metodo: int) -> tuple[list[np.ndarray], list[str]]:
    """
    Carga y procesa datos de imágenes en paralelo.

    Args:
        trainLabel (dict[str, str]): Un diccionario de etiquetas.
        funcion (callable): La función de procesamiento a aplicar.
        images (list[str]): La lista de archivos de imágenes.
        caracter (str): El caracter a buscar en la función de procesamiento.
        valor (any): El valor de reemplazo para la función de procesamiento.
        metodo (int): El método de interpolación de OpenCV.

    Returns:
        tuple[list[np.ndarray], list[str]]: Una tupla de listas que contiene las imágenes procesadas y sus etiquetas.
    """
    data = []
    labels = []

    for i in images:
        imagen = file_to_image(i, funcion, caracter, valor, metodo)
        if imagen.size != 0:
            data.append(imagen)
            Id = os.path.splitext(i)[0]
            label = trainLabel[Id]
            labels.append(label)

    return data, labels

def load_and_preprocess_data_paralelo(nr_procesos: int, funcion, caracter: str, valor: any, metodo: int) -> tuple[np.ndarray, np.ndarray]:
    """
    Carga y procesa datos de imágenes en paralelo utilizando múltiples procesos.

    Args:
        nr_procesos (int): El número de procesos a utilizar.
        funcion (callable): La función de procesamiento a aplicar.
        caracter (str): El caracter a buscar en la función de procesamiento.
        valor (any): El valor de reemplazo para la función de procesamiento.
        metodo (int): El método de interpolación de OpenCV.

    Returns:
        tuple[np.ndarray, np.ndarray]: Una tupla de arreglos que contiene las imágenes procesadas y sus etiquetas.
    """
    p = mp.Pool(nr_procesos)
    _, trainLabel, images = leer_csv_ruta("train", "trainLabels.csv")

    reparto_doc = reparte(len(images), nr_procesos)
    archivos = generar_listas(reparto_doc, images)
    args_list = [(trainLabel, funcion, archivo, caracter, valor, metodo) for archivo in archivos]
    resultados = p.starmap(load_and_preprocess_data, args_list)

    data = np.array(concat(list(map(lambda x: x[0], resultados))))
    label = np.array(concat(list(map(lambda x: x[1], resultados))))

    return data, label

if __name__ == "__main__":
    # Parámetros iniciales
    interpolation_methods = ["random", cv2.INTER_CUBIC, cv2.INTER_NEAREST]
    nombres = ["sustituir0Random.pkl", "sustituir0Cubic.pkl", "sustituir0Near.pkl"]
    funcion = sustituir
    caracter = "?"
    valor = "0"
    metodo = cv2.INTER_LINEAR
    _, trainLabel, images = leer_csv_ruta("train", "trainLabels.csv")

    # Cargar los datos. Con 6 procesadores se obtiene los mejores resultados en términos de tiempo.
    sustituir0Random = load_and_preprocess_data_paralelo(6, funcion, caracter, valor, interpolation_methods[0])
    with open('sustituir0Random.pkl', 'wb') as f:
        pickle.dump(sustituir0Random, f)
    sustituir0Cubic = load_and_preprocess_data_paralelo(6, funcion, caracter, valor, interpolation_methods[1])
    with open('sustituir0Cubic.pkl', 'wb') as f:
        pickle.dump(sustituir0Cubic, f)
    sustituir0Near = load_and_preprocess_data_paralelo(6, funcion, caracter, valor, interpolation_methods[2])
    with open('sustituir0Near.pkl', 'wb') as f:
        pickle.dump(sustituir0Near, f)





